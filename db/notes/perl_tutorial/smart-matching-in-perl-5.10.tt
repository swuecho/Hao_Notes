=title Smart Matching in Perl 5.10
=timestamp 2012-07-06T11:45:56
=indexes ~~, smart match, v5.10, 5.010
=status show
=author szabgab
=index 1
=archive 1
=feed 1
=comments 1
=social 1

=abstract start



Perl 5.10 于 Perl 20 周年发布（2007年 12月 18 日）。该版本增添来很多有意思的特性

在 <a href="/what-is-new-in-perl-5.10--say-defined-or-state">What's new in Perl 5.10? say, //, state</a> 一文中，
我已经写了一些。接下来，我们学习 <b>Smart Matching</b>。 


=abstract end

译者注：本文做了比较大的调整，只介绍我认为比较有用的部分。有些内容参考来Perl 官方文档。更多信息参考Perl 官方文档。

Perl的独特之处在于，所有的 Perl 操作符都作用于特定的情形，如果其操作子不符合此情形，Perl会自动转化。比如 1 + 1 结果为 2，多数语言都是这样，但是 1 + "1"呢，
很多语言中是错误的，但是由于 Perl 的操作符作用与特定情形， “1” 首先被转换成 1 然后再加。再如，如果你想比较两个数是否相等，用 “==”；如果相比较两个字符串是否相等，用 “eq”。然而，~~ 是个例外，~~ 从其操作子中推断其所处的情形，然后选择合适的比较方法。

5.10增加了一个新的操作符<b>~~</b>，叫做 <b>Smart Matching</b> 操作符。因为太灵活，有时候会引起混乱，Smart Matching 出来后有不少争论。如果你现在使用的版本低于5.14，不建议使用。如果学习的成本大于使用带来的收益，就不要用它，本文只介绍比较好用的部分。


~~ 与 == eq 具有同样的优先级。$a ~~ $b，多数情况下读做 $a 属于 $b 或 $a 在 $b 中比较好。与其它的比较操作符类似，$a ~~ $b 的结果为 1 或者 “”，对应于 true 和 false。前面已经提到，~~ 从其操作子中推断其所处的情形，然后选择合适的比较方法。这里只介绍3种。

<h2>1. Any ~~ Array </h2>

~~ 的作用是，查看 Any 是否属于 Array。

<code lang="perl">
my @b [qw(Foo Bar Baz)];
"Moose" ~~ @b    #  is false

my @c = [qw(Foo Bar Moose Baz)];
"Moose" ~~ @c #  is true
</code>


“Moose”在 [qw(Foo Bar Moose Baz)] 中，所以结果是 1，不在 [qw(Foo Bar Baz)] 中 ，所以结果是 “”。


上个例子可以简写如下：

<code lang="perl">
"Moose" ~~ [qw(Foo Bar Baz)]  ;     #  is false
"Moose" ~~ [qw(Foo Bar Moose Baz)] ;#  is true
</code>


请注意，这个例子与上一个例子的区别。~~ 可以是 Array 也可一是 Array 的引用, 如果是后者，Perl 自动取出被引用的值，然后比较。


当然，也可以看某个数值是否在数组中;

<code lang="perl">
42 ~~ [23, 17, 70]          # false
42 ~~ [23, 17, 42, 70]      # true
<code>




<h2> 2. Any ~~ Hash </h2>

$a ~~ $b 的右边也可以是 Hash，~~ 的作用是，查看 $a 属于 Hash 的 Keys 的集合。

比如:

<code lang="perl">
'a' ~~ {a => 19, b => 23}        true
19  ~~ {a => 19, b => 23}        false
</code>


'a' 与 {a => 19, b => 23} 的其中一个 key ‘a’ 相同，所以结果是 1。 


<h2> 3. Any ~~ CODE </h2>

Any ~~ CODE 相当与 CODE->(Any)

<code lang="perl">
3 ~~ sub { $_[0] % 2 == 0 };  # false
2 ~~ sub { $_[0] % 3 == 0 };  # false
<code>

如果把 Any ~~ CODE 与 Any ~~ Array 结合起来，将变得更有意思。

<code lang="perl">
7 ~~ [sub { $_[0] % 2 == 0 }, sub { $_[0] % 3 == 0 }];  # false
4 ~~ [sub { $_[0] % 2 == 0 }, sub { $_[0] % 3 == 0 }];  # true
<code>

7 既不能被 2 也不能被3 整除，所以结果是 false；
4 能被 2 整除，所以结果为 true。









如果你想比较两个数是否相等，用 “==”；如果相比较两个字符串是否相等，用 “eq”。

“~~” 的用法与 “==” “eq” 有类似之处。除非找到更好的方法，<b> Smart Matching <b> ，把其两边的两个值当作字符串来比较（等价于 eq）。
 
比如，以下结果都为 true，即 1。
<code lang="perl">
"Foo" ~~ "Foo"
42    ~~ 42
42    ~~ 42.0
42    ~~ "42.0"
</code>

以下都是 false

<code lang="perl">
"Foo"  ~~ "Bar"
42     ~~ "42x"
</code>

And that is already a nice advantage over what we had earlier.


Perl的一个独特之处是，Perl 根据操作符来决定值的类型。比如，== 操作符把其操作子当作数值然后进行比较；
eq 操作符把其操作子当作字符串然后进行比较。

如果 == 的两边有字符串，Perl 从字符串的左边尽可能多的读取可以被看作数子的值。如果遇到非数字，终止读值，并给出警告。



On the other hand ~~ fits the comparison method to the values on the two sides.

<br>
In a smart way.

This means that these are all true:

<code lang="perl">
42 == 42
42 == 42.0
42 == "42.0"
42 == "42\n"
</code>

but this is false:

<code lang="perl">
42 eq "42.0"
42 eq "42\n"
</code>

and the following are true:

<code lang="perl">
42 == "42x"
"Foo" == "Bar"
</code>

albeit with a warning...<br>
if you used <b>use warnings</b>...

This behavior while consistent is a bit hard to understand.

On the other hand the new ~~ is strange in another way.
Its comparison is <b>value driven</b> as opposed to the other operations in
Perl which are <b>operator driven</b>.
<hr>

Let's see it in a different approach: As I wrote ~~ will compare the values
as strings using eq, unless it finds some better way to compare them.

<code lang="perl">
"Foo" ~~ "Bar"
</code>

will return false but

<code lang="perl">
"Moose" ~~ "Moose"
</code>

will return true. Nothing to surprise us.

So what better ways might be there to compare two scalars?

I wrote a small function that can be used to see what smart matching does.

<code lang="perl">
sub compare {
    my ($x, $y, $description) = @_;
    my $t = ($x ~~ $y ? "True" : "False");
    $x //= '';
    $y //= '';
    printf("%-4s ~~ %-4s is %-5s   (%s)\n", $x, $y, $t, $description);
}
</code>

This will get two values (and a description) and compare the two
with smart matching printing the result. So I can now supply two
values two this function and see how are the respective variables compared.

So <hl>"Foo" ~~ "Bar"</hl> is the same as <hl>"Foo" eq "Bar"</hl>,
(this is called <hl>Any ~~ Any</hl> in the documentation)

If one side is a number, it seems to be better to compare them as numbers (using ==)
<hl>42 ~~ 42.0</hl>  are compared using <hl>==</hl> (this is called <hl>Any ~~ Num</hl>)

If one side is Number but the other one is a string (eg. "xyz" or "23xxyz") then
we would be better off comparing with eq and not trying to change them to numbers.
Hence:

<code lang="perl">
42 ~~ "42.0x"  are compared using eq (this is called Any ~~ Str)
</code>

But what if the string is actually including a numish value, such as
"42" or "42.0" or even "42\n" to forgive those who forget to chomp()?

The following are all compared as numbers so they are true:

<code lang="perl">
42 ~~ "42"
42 ~~ "42.0"
42 ~~ "42\n"
42 ~~ "42 "
</code>

This is called (Num ~~ numish)

There is a strange thing though, and I am not yet sure what is
its purpose but if both are numish then they are compared as strings,
and this will yield false:

<code lang="perl">
"42" ~~ "42.0"
</code>

I have a posted a question regarding this on
<a href="http://perlmonks.org/?node_id=658876">PerlMonks</a> where
you might find the answer.

But ~~ can do more. If one of the values in an == or eq is undef,
Perl will complain about that. Smart Matching on the other hand
understands that an undef is just an undef. So if one of the
values is undef then ~~ checks if the other one is undef too using
defined();

So these are false:

<code lang="perl">
3 ~~ undef
"x" ~~ undef
</code>

While this is true:

<code lang="perl">
undef ~~ undef
</code>

除了比较两个标量之外，~~ 还能检查正则式是否匹配。

TODO 查看 =~ 的文档。

<code lang="perl">
"Perl 5.10" ~~ /Moose/
/Moose/ ~~ "Perl 5.10"
"Perl 5.10" ~~ qr/Moose/
qr/Moose/ ~~ "Perl 5.10"
</code>

<hr>


但是，在以上的情形，不推荐用 ~~。什么时候用呢？两边不全是简单的标量的时候。


<h2> ( Scalar ~~ Array) <h2>



<code lang="perl">
"Moose" ~~ [qw(Foo Bar Baz)]         is false
"Moose" ~~ [qw(Foo Bar Moose Baz)]   is true
</code>

估计你能猜到上面例子的结果。“~~” 查看 “Moose” 是否存在于Array 中。


The smart match will do The Right Thing, it will check if the given scalar value is
the same as one of the elements in the Array.  (Str ~~ Array)



The way the individual values are compared is based on the type of the scalar.
So if the scalar is a string all the values of the array are compared to the
string using "eq" while if the scalar is a number, all the comparisons will
be done by "==".

(Str ~~ Array   and    Num ~~ Array  in the documentation)

So

<code lang="perl">
42 ~~ [23, 17, 70]          # false
42 ~~ [23, 17, 42, 70]      # true
42 ~~ [23, 17, "42\n", 70]  # true
42 ~~ [23, 17, "42 ", 70]   # true

42 ~~ [23, 17, "42x", 70]   # in 5.12 this was true with a warning
                            # Argument "42x" isn't numeric in smart match
                            # in 5.14 this is false and no warning
</code>


So that actually means we now have an operator to check if an individual scalar
is represented in an array. It still slower than a hash lookup but it is faster
than a grep that most people use. It is definitely easier to write.

Similarly we can have a hash reference instead of one of the values and
~~ will check if the given scalar is one of the keys in the hash:
That is, using exists();     (Any ~~ Hash)

<code lang="perl">
'a' ~~ {a => 19, b => 23}        true
42  ~~ {a => 19, b => 23}        false
</code>

But that is a bit less interesting in this context.

As a side note, instead of reference to Array or reference to Hash
you can actually put there the real Array or the real Hash
(but not a simple list) so this works and it is true:

<code lang="perl">
my @a = (2, 3);
say 3 ~~ @a ? "T" : "F";
</code>

but this did not work in 5.10.

<code lang="perl">
say 3 ~~ (2, 3) ? "T" : "F";
</code>

It works in 5.14 though.

The obvious question is then, what happens when both sides are
complex data structures Arrays or Hashes?

With Arrays, it will check if each element is the same  (Array ~~ Array)

<code lang="perl">
["Foo", "Bar"] ~~ ["Foo", "Bar"]          is true
["Foo", "Bar"] ~~ ["Foo", "Bar", "Baz"]   is false
[1,2,3] ~~ [1,2,3]                        is true
</code>

With hashes it checks if the keys are identical  (Hash ~~ Hash)

This used to work in 5.10 but gives a syntax error in 5.14:

<code lang="perl">
{Foo => 19, Bar => 23} ~~ {Foo => 23, Bar => 19}     is true
</code>

and the checking is done in any deep structure:

<code lang="perl">
["Foo", ["Bar", "Baz"]] ~~ ["Foo", ["Bar", "Baz"]]
</code>

There are several more cases but even this was probably too much for an introduction.

<hr>

更详细的解释参加 Perl 5 文档 <a href="http://perldoc.perl.org/perlsyn.html">perlsyn</a> .
<i>"Smart matching in detail"</i> 部分。

<h2>结尾</h2>
在5.10，5.12中，不推荐使用 ~~。5.14以后的版本，推荐使用。





